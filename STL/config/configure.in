dnl Disable any caching here 
define([AC_CACHE_LOAD], )dnl
define([AC_CACHE_SAVE], )dnl
dnl Process this file with autoconf to produce a configure script.
AC_INIT(stlconf.h)
AC_CONFIG_HEADER(stlconf.h:config/stlconf.h)

AC_MSG_RESULT(*** $0: STLport configuration utility ***)
if test "${CXXFLAGS}" = ""; then 
AC_MSG_RESULT(* Note: for best reliability - try \"CXXFLAGS=-treat_warnings_as_errors\" $0 )
AC_MSG_RESULT(* Please don't forget specifying typical CXXFLAGS you'll be using - ) 
AC_MSG_RESULT(* such as that enabling exceptions handling, etc. )
dnl AC_MSG_RESULT(* Add option forcing instantiation of all templates to CXXFLAGS if possible. )
fi
AC_MSG_RESULT(Please stand by while exploring compiler capabilities...)
AC_MSG_RESULT(Be patient - that may take a while...)
AC_MSG_RESULT(***)

# utility function
check_warning () {
    warn_str=`tail -1 config.log | egrep -i "arning|\(W\)"`
    if test "$warn_str" = ""; then
      return 0
    else
     return 1
    fi
}

dnl Checks for systems
dnl AC_AIX
dnl Checks for programs.
dnl sets CXX

AC_ARG_ENABLE(extension,[--enable-extension=<ext>],
[
case "$enableval" in
	no) AC_MSG_RESULT(Info :.cpp used as extension for tests) 
	    ac_ext=cpp 
      	;;
	 *) AC_MSG_RESULT(Argument : .$enableval used as extension) 
	ac_ext=$enableval
esac
],
[AC_MSG_RESULT(Info : .cpp used as extension for tests) 
	ac_ext=cpp
]
)

# Save that, as it is being redefined several times 
use_ac_ext=$ac_ext

AC_PROG_CXX
ac_ext=$use_ac_ext

AC_LANG_CPLUSPLUS
ac_ext=$use_ac_ext

AC_CHECK_SIZEOF(int,4)
ac_ext=$use_ac_ext

if test "$ac_cv_sizeof_int" = "4"; then
  AC_DEFINE_UNQUOTED(__STL_UINT32_T,unsigned int)
else
  AC_CHECK_SIZEOF(long,4)
  ac_ext=$use_ac_ext
  if test "$ac_cv_sizeof_long" = "4"; then
    AC_DEFINE_UNQUOTED(__STL_UINT32_T,unsigned long)
  else
  dnl ELBRUS ??? ;)
    AC_CHECK_SIZEOF(short,4)
    if test "$ac_cv_sizeof_short" = "4"; then
      AC_DEFINE_UNQUOTED(__STL_UINT32_T,unsigned short)
    else
      AC_MSG_ERROR(Cannot find any 32-bit integer type for your compiler)
    fi
  ac_ext=$use_ac_ext
  fi
fi
ac_ext=$use_ac_ext


dnl Exclude link stage for cross-compilation
if test "$ac_cv_c_cross" = "yes"; then
  CXXFLAGS="${CXXFLAGS} -c"
fi

ac_ext=$use_ac_ext

dnl checking for compiler capabilities
AC_MSG_CHECKING(for basic STL compatibility)
AC_TRY_LINK( [
template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};      
template <class T>
struct plus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const;
};

template <class T>
T plus<T>::operator()(const T& x, const T& y) const { return x + y; }
plus<int> p;
],
[], 
[ac_cv_compat="yes"],
[AC_MSG_ERROR(Your compiler won't be able to compile this implementation. Sorry.) 
 ac_cv_compat="no"]
)
AC_MSG_RESULT($ac_cv_compat)

AC_MSG_CHECKING(for new-style headers)
AC_TRY_COMPILE(
    [
     #include <new>
     #include <iosfwd>
     #include <iostream>
       ],
    [],
    [AC_DEFINE(__STL_USE_NEW_STYLE_HEADERS) ac_cv_newheaders="yes"],
    [ac_cv_newheaders="no"])
AC_MSG_RESULT($ac_cv_newheaders)

AC_MSG_CHECKING(for bool keyword)
AC_TRY_COMPILE(
    [bool b_foo() { return true; }],
    [(void)b_foo();],
    [AC_DEFINE(__STL_BOOL_KEYWORD) ac_cv_bool="yes"],
    [ac_cv_bool="no"])
AC_MSG_RESULT($ac_cv_bool)
if test "$ac_cv_bool" = "no"; then
  AC_MSG_CHECKING(for yvals.h header)
  AC_TRY_COMPILE([#include <yvals.h> 
    extern bool aaa=true;
   ], [], 
  [AC_DEFINE(__STL_YVALS_H) AC_MSG_RESULT(yes) ], 
  [
  AC_MSG_RESULT(no)
  AC_MSG_CHECKING(whether bool is reserved word)
  AC_TRY_COMPILE(
    [typedef int bool;],
    [],
    [ac_cv_bool_reserved="no"],
    [AC_DEFINE(__STL_RESERVED_BOOL_KEYWORD) ac_cv_bool_reserved="yes"])
  AC_MSG_RESULT($ac_cv_bool_reserved)
  ])
fi

AC_MSG_CHECKING(for wchar_t type)
AC_TRY_COMPILE(
    [wchar_t wc_foo() { return 'a'; }],
    [(void)wc_foo();],
    [AC_DEFINE(__STL_WCHAR_T) ac_cv_wchar="yes"],
    [ac_cv_wchar="no"])
AC_MSG_RESULT($ac_cv_wchar)

AC_MSG_CHECKING(for long long type)
AC_TRY_COMPILE(
    [long long ll_foo() { return 0; }],
    [(void)ll_foo();],
    [AC_DEFINE(__STL_LONG_LONG) ac_cv_long_long="yes"],
    [ac_cv_long_long="no"])
AC_MSG_RESULT($ac_cv_long_long)

AC_MSG_CHECKING(for long double type)
AC_TRY_COMPILE(
    [long double ld_foo() { return 0; }],
    [(void)ld_foo();],
    [AC_DEFINE(__STL_LONG_DOUBLE) ac_cv_long_double="yes"],
    [ac_cv_long_double="no"])
AC_MSG_RESULT($ac_cv_long_double)

AC_MSG_CHECKING(for separate template compilation support)
AC_TRY_LINK( [
#include "config/sc_foo.h"
],
[
sc_foo<int> foo;
foo.bar(0);
], 
[AC_DEFINE(__STL_SEPARATE_TEMPLATE_BODY) ac_cv_separate_body="yes"],
[ac_cv_separate_body="no"]
)
AC_MSG_RESULT($ac_cv_separate_body)


AC_MSG_CHECKING(for member template methods)
AC_TRY_LINK( [
template <class Result>
struct mt_foo {
    typedef Result result_type;
    template <class Arg> result_type operate(const Arg&) { return Result(); }
};      
mt_foo<int> p;
],
[
(void)p.operate((char*)"aaa");
], 
[AC_DEFINE(__STL_MEMBER_TEMPLATES) ac_cv_member_templates="yes"],
[ac_cv_member_templates="no"]
)
AC_MSG_RESULT($ac_cv_member_templates)

AC_MSG_CHECKING(for friend templates)
AC_TRY_LINK( [
template <class Result>
struct ft_foo {
    typedef Result result_type;
    template <class Result2> friend class foo;
};      
ft_foo<int> p;
],
[], 
[AC_DEFINE(__STL_FRIEND_TEMPLATES) ac_cv_friend_templates="yes"],
[ac_cv_friend_templates="no"]
)
AC_MSG_RESULT($ac_cv_friend_templates)

AC_MSG_CHECKING(for member template classes)
AC_TRY_LINK( [
template <class Result>
struct nt_foo {
    typedef Result result_type;
    template <class Arg> class nested { Arg body; };
};      
nt_foo<int> p;
nt_foo<int>::nested<char> pp;
],
[], 
[AC_DEFINE(__STL_MEMBER_CLASS_TEMPLATES) ac_cv_member_template_classes="yes"],
[ac_cv_member_template_classes="no"]
)
AC_MSG_RESULT($ac_cv_member_template_classes)

AC_MSG_CHECKING(for partial class specialization)
AC_TRY_LINK( [
template <class Arg,class Result>
struct ps_foo {
    typedef Arg argument_type;
    typedef Result result_type;
};   

template<class Result>
struct ps_foo<Result*,Result*> {
	void bar() {}
};

template<class Result>
struct ps_foo<int*,Result> {
	void foo() {}
};

ps_foo<char*, char*> p;
ps_foo<int*, int> p1;
],
[p.bar();
 p1.foo();], 
[AC_DEFINE(__STL_CLASS_PARTIAL_SPECIALIZATION) ac_cv_partial_spec="yes"],
[ac_cv_partial_spec="no"]
)
AC_MSG_RESULT($ac_cv_partial_spec)

AC_MSG_CHECKING(for partial template function ordering)
AC_TRY_LINK( [
template<class Result>
Result po_foo (const int& a, const Result&){ return (Result)a; }   
template <class Arg,class Result>
Result po_foo (const Arg& a,const Result&){ return (Result)a.nothing; }  
],
[ int po_b; char po_a; (void)po_foo(po_b, po_a);],
[AC_DEFINE(__STL_FUNC_PARTIAL_ORDERING) ac_cv_partial_ord="yes"],
[ac_cv_partial_ord="no"]
)
AC_MSG_RESULT($ac_cv_partial_ord)

AC_MSG_CHECKING(for method specialization)
AC_TRY_LINK( [
template <class Arg,class Result>
struct ms_foo {
    typedef Arg argument_type;
    typedef Result result_type;
    inline void bar();
};   

template <class Arg,class Result>
inline void ms_foo<Arg,Result>::bar() {}

inline void ms_foo<int*,int>::bar() {}

ms_foo<char*, char*> p;
ms_foo<int*, int> p1;
],
[p.bar();
 p1.bar();], 
[AC_DEFINE(__STL_METHOD_SPECIALIZATION) ac_cv_method_spec="yes"],
[ac_cv_method_spec="no"]
)
AC_MSG_RESULT($ac_cv_method_spec)

AC_MSG_CHECKING(for lrand48 function)
AC_TRY_LINK(
    [#include <stdlib.h>],
    [long i = lrand48();],
    [AC_DEFINE(__STL_RAND48) ac_cv_func_lrand48="yes"],
    [ac_cv_func_lrand48="no"])
AC_MSG_RESULT($ac_cv_func_lrand48)


AC_MSG_CHECKING(for default template parameters)
AC_TRY_LINK(
    [template <class T> struct less {}; 
     template <class T, class T1=less<T> > struct Class { T1 t1; };
     Class<int> cl;
     Class<int,less<short> > cl2;
    ],
    [],
    [AC_DEFINE(__STL_DEFAULT_TEMPLATE_PARAM) ac_cv_default_template_param="yes"],
    [ac_cv_default_template_param="no"])
AC_MSG_RESULT($ac_cv_default_template_param)
if test "$ac_cv_default_template_param" = "no"; then
  AC_MSG_CHECKING(for default type parameters)
  AC_TRY_LINK(
    [
template <class T> class less {}; 

template <class T, class T1=less<int> > 
struct Class { 
private:
       int a;
public:
       typedef Class<T,T1> self; 
       self foo (const Class<T,T1>& t) { 
         if ( t.a==a ) return *this;
         else return t;
         } 
};

Class<int> cl;
Class<int,less<short> > cl2;
    ],
    [],
    [AC_DEFINE(__STL_DEFAULT_TYPE_PARAM) ac_cv_default_type_param="yes"],
    [ac_cv_default_type_param="no"])
  AC_MSG_RESULT($ac_cv_default_type_param)

fi

dnl let's check if non-type cannot be default

AC_MSG_CHECKING(for default non-type parameters)
AC_TRY_LINK(
    [
template <class T, int N=0 > 
struct Class { 
private:
       T* t;
       enum { t1=N };
public:
       int get_n() { return N; }
};

Class<int> cl;
Class<int, 2> cl2;
    ],
    [],
    [ac_cv_default_nontype_param="yes"],
    [AC_DEFINE(__STL_NO_DEFAULT_NON_TYPE_PARAM) ac_cv_default_nontype_param="no"]
	)
AC_MSG_RESULT($ac_cv_default_nontype_param)

AC_MSG_CHECKING(for non-type parameter bug)
AC_TRY_LINK(
    [
template <class T, int N> 
struct Class { 
private:
       T* t;
       enum { t1=N };
public:
       int get_n() { return N; }
};

template <class T, int N>
int operator==(const Class<T,N>& , const Class<T,N>& ) { return 0; }

Class<int, 1> cl;
Class<int, 1> cl2;
int i(cl==cl2);
    ],
    [],
    [ac_cv_nontype_param_bug="no"],
    [AC_DEFINE(__STL_NON_TYPE_TMPL_PARAM_BUG) ac_cv_nontype_param_bug="yes"]
	)
AC_MSG_RESULT($ac_cv_nontype_param_bug)

AC_MSG_CHECKING(for static data member templates)
AC_TRY_LINK(
    [template <class T> struct Class { static int a; };
     template <class T> int Class<T>::a;],
    [],
    [AC_DEFINE(__STL_STATIC_TEMPLATE_DATA) ac_cv_static_templates="yes"],
    [ac_cv_static_templates="no"])
AC_MSG_RESULT($ac_cv_static_templates)

if test "$ac_cv_static_templates" = no; then
 AC_MSG_CHECKING(for weak attribute)
 AC_TRY_COMPILE(
    [int a_w __attribute__((weak));],
    [],
    [AC_DEFINE(__STL_WEAK_ATTRIBUTE) ac_cv_weak_attribute="yes"],
    [ac_cv_weak_attribute="no"])
 AC_MSG_RESULT($ac_cv_weak_attribute)
fi

if test "$ac_cv_static_templates" = yes; then
AC_MSG_CHECKING(for static array member size bug)
AC_TRY_LINK(
    [template <class T> struct Class { enum { sz=5 }; static int a[sz]; };
     template <class T> int Class<T>::a[Class<T>::sz];],
    [],
    [ac_cv_static_array_bug="no"],
    [AC_DEFINE(__STL_STATIC_ARRAY_BUG) ac_cv_static_array_bug="yes"])
AC_MSG_RESULT($ac_cv_static_array_bug)
fi

AC_MSG_CHECKING(for namespaces support)
AC_TRY_COMPILE(
    [namespace std { 
      template <class T> struct Class { typedef T my_type; };
      typedef Class<int>::my_type int_type;
	}; 
    inline int ns_foo (std::int_type t) { 
      using namespace std; 
      int_type i =2;
      return i+t; 
    }
    namespace my_std=std; 
     ],
    [(void)ns_foo(1);],
    [ac_cv_namespaces="yes"],
    [ac_cv_namespaces="no"])
if test "$ac_cv_namespaces" = yes; then
# check if no warnings have been issued
  if `check_warning` ; then
    AC_DEFINE(__STL_NAMESPACES)
  else
   ac_cv_namespaces=no
  fi
fi
AC_MSG_RESULT($ac_cv_namespaces)

AC_MSG_CHECKING(for typename keyword)
AC_TRY_LINK(
    [
template <class T1, class T2>
struct pair {
    typedef T1 first_type;
    typedef T2 second_type;
};

template <class Arg, class Result>
struct unary_function {
    typedef Arg argument_type;
    typedef Result result_type;
};

template <class Pair>
struct select2nd : public unary_function<Pair, typename Pair::second_type> {
  typedef typename Pair::first_type ignored_type;
  const typename Pair::second_type& operator()(const typename Pair::second_type& x,
						const ignored_type& ) const
  {
    return x;
  }
  
};
    ],
    [ 
	typedef pair<int,int> tn_p;
	select2nd< tn_p > tn_s;
	(void)tn_s(1,5);
    ],
    [__TYPENAME="typename" 
     AC_DEFINE(__STL_TYPENAME) 
     ac_cv_typename="yes"],
    [__TYPENAME="" 
     ac_cv_typename="no"])
AC_MSG_RESULT($ac_cv_typename)

AC_MSG_CHECKING(for explicit keyword)
AC_TRY_COMPILE(    
    [struct expl_Class { int a; explicit expl_Class(int t): a(t) {} };
    expl_Class c(1);
    ],
    [],
    [AC_DEFINE(__STL_EXPLICIT) ac_cv_explicit="yes"],
    [ac_cv_explicit="no"])
AC_MSG_RESULT($ac_cv_explicit)

AC_MSG_CHECKING(for mutable keyword)
AC_TRY_COMPILE(    
    [struct mut_Class { mutable int a; void update() const { a=0; }  };
    mut_Class c;
    ],
    [c.update()],
    [AC_DEFINE(__STL_MUTABLE) ac_cv_mutable="yes"],
    [ac_cv_mutable="no"])
AC_MSG_RESULT($ac_cv_mutable)

AC_MSG_CHECKING(for new style casts)
AC_TRY_COMPILE(    
    [struct ncast_Class { 
	int a; void update(int* i) { *i=a; }  };
    ncast_Class c;
    ],
    [
  const int a(5);
  c.update(const_cast<int*>(&a))
    ],
    [AC_DEFINE(__STL_NEW_STYLE_CASTS) ac_cv_new_cast="yes"],
    [ac_cv_new_cast="no"])
AC_MSG_RESULT($ac_cv_new_cast)

AC_MSG_CHECKING(for exceptions support)
AC_TRY_COMPILE(
    [int ex_foo() { 
       try { 
         try { throw(1); } 
         catch (int a) { throw; } 
       } catch (...) {;} 
      return 0;
    }],
    [(void)ex_foo();],
    [ac_cv_exceptions="yes" ],
    [ac_cv_exceptions="no"])
AC_MSG_RESULT($ac_cv_exceptions)
if test "$ac_cv_exceptions" = yes; then
 AC_DEFINE(__STL_USE_EXCEPTIONS)
 AC_MSG_CHECKING(if exceptions specification make things better)
 AC_TRY_COMPILE(
    [template <class T> inline int ex_spec_foo(const T&) throw () { return 0;} ], 
    [(void)ex_spec_foo(5);],
    [ac_cv_exception_spec="yes"],
    [ac_cv_exception_spec="no"])
    if test "$ac_cv_exception_spec" = yes; then
    # check if no warnings have been issued
     if `check_warning` ; then
       AC_DEFINE(__STL_EXCEPTION_SPEC)
     else
      ac_cv_exception_spec=no
     fi
    fi
 AC_MSG_RESULT($ac_cv_exception_spec)
fi

AC_MSG_CHECKING(for trivial constructor bug)
AC_TRY_LINK(
    [struct output_iterator_tag {};
     void tc_bug_foo(output_iterator_tag) {}
     inline void tc_test_foo()  { tc_bug_foo(output_iterator_tag()); }],
    [tc_test_foo();],
    [ac_cv_tc_bug="no"],
    [AC_DEFINE(__STL_TRIVIAL_CONSTRUCTOR_BUG) ac_cv_tc_bug="yes"])
AC_MSG_RESULT($ac_cv_tc_bug)

AC_MSG_CHECKING(for trivial destructor bug)
AC_TRY_LINK(
    [struct output_iterator_tag {output_iterator_tag() {} };
	output_iterator_tag* td_bug_bar ;
	],
    [ td_bug_bar->~output_iterator_tag();
     ],
    [ac_cv_td_bug="no"],
    [AC_DEFINE(__STL_TRIVIAL_DESTRUCTOR_BUG) ac_cv_td_bug="yes"])
AC_MSG_RESULT($ac_cv_td_bug)

AC_MSG_CHECKING(for template parameter baseclass matching)
AC_TRY_LINK(
    [struct output_iterator_tag {};
     struct derived1_tag : public output_iterator_tag {};
     struct derived2_tag : public derived1_tag {};
     template<class T> struct output_iterator { 
	public:
	output_iterator() {} 
	~output_iterator() {} 
	friend inline int operator==(const output_iterator<T>&, 
                                      const output_iterator<T>&);
	};
     template<class T> int operator==(const output_iterator<T>&, 
                                      const output_iterator<T>&) {
       return 0;
     }
     template<class T> inline output_iterator_tag
     iterator_category(const output_iterator<T>&) {return output_iterator_tag();}
     template <class T>
     struct derived_iterator : public output_iterator<T> {
	public:
	derived_iterator() {} 
	~derived_iterator() {}
	};
     template<class T> inline T select_foo(T t, output_iterator_tag) { return t;}     
     template<class T> inline int select_foo_2(T, T,
                                             output_iterator_tag) { return 0;}     
     template<class T> inline T tbase_foo(T pm )  { 
	derived_iterator<T> di1, di2; int i( di1==di2 && pm);
	return select_foo((int)1,iterator_category(derived_iterator<T>())); 
    }
    ],
    [ (void)tbase_foo((int)1); ],
    [ac_cv_base_match="yes"],
    [AC_DEFINE(__STL_BASE_MATCH_BUG) ac_cv_base_match="no"])
AC_MSG_RESULT($ac_cv_base_match)

AC_MSG_CHECKING(for non-template parameter baseclass matching )
AC_TRY_LINK(
    [struct output_iterator_tag {};
     struct derived1_tag : public output_iterator_tag {};
     struct derived2_tag : public derived1_tag {};
     template<class T> struct output_iterator { 
	public:
	output_iterator() {} 
	~output_iterator() {} 
	};
     template<class T> inline output_iterator_tag
     iterator_category(const output_iterator<T>&) {return output_iterator_tag();}
     template <class T>
     struct derived_iterator : public output_iterator<T> {
	public:
	derived_iterator() {} 
	~derived_iterator() {}
	};
     template<class T> inline int select_foo_2(T, T,
                                             output_iterator_tag) { return 0;}     
     template<class T> inline T nont_base_foo(T pm )  { 
	derived_iterator<T> di1, di2; 
	(void)select_foo_2(di1, (const derived_iterator<T>&)di2, derived2_tag());
    }
    ],
    [ (void)nont_base_foo((int)1); ],
    [ac_cv_nont_base_match="yes"],
    [AC_DEFINE(__STL_NONTEMPL_BASE_MATCH_BUG) ac_cv_nont_base_match="no"])
AC_MSG_RESULT($ac_cv_nont_base_match)

AC_MSG_CHECKING(for nested type parameters bug)
AC_TRY_LINK(
    [template<class T> struct nt_o { typedef int ii; inline ii foo(ii);};
     template <class T> inline nt_o<T>::ii nt_o<T>::foo(ii) { return 0; }],
    [],
    [ac_cv_nested_type_param_bug="no"],
    [AC_DEFINE(__STL_NESTED_TYPE_PARAM_BUG) ac_cv_nested_type_param_bug="yes"])
AC_MSG_RESULT($ac_cv_nested_type_param_bug)


AC_MSG_CHECKING(if inherited template typedefs broken completely)
AC_TRY_LINK(
    [
template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};     

template <class T>
struct equal_to : public binary_function<T, T, int> {
    int operator()(const T& x, const T& y) const { return x == y; }
};

template <class Predicate> 
class binary_negate 
    : public binary_function<$__TYPENAME Predicate::first_argument_type,
			     $__TYPENAME Predicate::second_argument_type, 
                             int> {
protected:
    Predicate pred;
public:
    binary_negate(const Predicate& x = Predicate()) : pred(x) {}
    int operator() (const $__TYPENAME Predicate::first_argument_type& x, 
		    const $__TYPENAME Predicate::second_argument_type& y) const {
	return !pred(x, y); 
    }
};
      typedef equal_to<int> eq_int;
      typedef binary_negate<equal_to<int> > int_negate;
      int_negate n;
 ],
    [
      (void)n(1,2);
    ],
    [ac_cv_typebug="no"],
    [AC_DEFINE(__STL_BASE_TYPEDEF_BUG) 
     AC_DEFINE(__STL_BASE_TYPEDEF_OUTSIDE_BUG) ac_cv_typebug="yes"])
AC_MSG_RESULT($ac_cv_typebug)

AC_MSG_CHECKING(if inherited typedefs visible from outside)
AC_TRY_COMPILE(
    [
template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg1 second_argument_type;
    typedef Result result_type;
};     


template <class T>
class plus : public binary_function<T, T, T> {
public:
    plus() {}
    plus(const T&) {}
    T operator()(const T& x, const T& y) const { return x + y; };
};

plus<int> p;
$__TYPENAME plus<int>::first_argument_type a;
],
    [],
    [ac_cv_outside_typedef="yes"],
    [AC_DEFINE(__STL_BASE_TYPEDEF_OUTSIDE_BUG) ac_cv_outside_typedef="no"])
AC_MSG_RESULT($ac_cv_outside_typedef)

# fi

AC_MSG_CHECKING(if private type static members initializable)
AC_TRY_COMPILE(
    [struct p_Class { private: struct str_ { 
	int a; str_(int i) : a(i) {}}; static str_ my_int; 
     };
     $__TYPENAME p_Class::str_ p_Class::my_int(0); 
     ],
    [],
    [ac_cv_private="yes"],
    [AC_DEFINE(__STL_UNINITIALIZABLE_PRIVATE) ac_cv_private="no"])
AC_MSG_RESULT($ac_cv_private)


AC_MSG_CHECKING(for const member constructor bug)
AC_TRY_LINK([
template <class T1, class T2>
struct pair {
    T1 first;
    T2 second;
    pair() {}
    pair(const pair<T1,T2>& o) : first(o.first), second(o.second) {}
};
pair< const int, const int > p;  
     ],
    [],
    [ac_cv_const_constructor_bug="no"],
    [AC_DEFINE(__STL_CONST_CONSTRUCTOR_BUG) ac_cv_const_constructor_bug="yes"])
AC_MSG_RESULT($ac_cv_const_constructor_bug)

AC_MSG_CHECKING(for loop inline problems)
AC_TRY_COMPILE(
    [inline int il_foo (int a) { 
      int i; for (i=0; i<a; i++) a+=a;  while (i>0) a-=3; return a; }],
    [(void)il_foo(2);],
    [ac_cv_inline_problems="no"],
    [AC_DEFINE(__STL_LOOP_INLINE_PROBLEMS) ac_cv_inline_problems="yes"])
if test "$ac_cv_inline_problems" = no; then
# check if no warnings have been issued
  if `check_warning` ; then
     ac_cv_inline_problems="no"
  else
   AC_DEFINE(__STL_LOOP_INLINE_PROBLEMS)
   ac_cv_inline_problems="yes"
  fi
fi
AC_MSG_RESULT($ac_cv_inline_problems)

AC_MSG_CHECKING(for full specialization syntax)
AC_TRY_LINK(
    [
     template <class T> class fs_foo {};
     template <> class fs_foo<int> {};],
    [ fs_foo<int> i;],
    [AC_DEFINE(__STL_FULL_SPEC_SYNTAX) ac_cv_spec_syntax="yes"],
    [ac_cv_spec_syntax="no"])
AC_MSG_RESULT($ac_cv_spec_syntax)

AC_MSG_CHECKING(if unused methods instantiated)
AC_TRY_LINK(
    [
     template <class T> struct um_foo { T* ptr; 
	T* operator ->() { return &(operator*());}
	T  operator *()  { return *ptr; }
     };
     template <class T>
	int operator == ( const um_foo<T>& x, const um_foo<T>& y)
	{
    		return *x == *y;
	}
     struct um_tag { int a ; };
     um_foo<um_tag> f;
     um_foo<int> a;
     ],
    [ 
     int b(5); a.ptr=&b;],
    [ac_cv_unused_required="no"],
    [AC_DEFINE(__STL_UNUSED_REQUIRED_BUG) ac_cv_unused_required="yes"]
    )
AC_MSG_RESULT($ac_cv_unused_required)

AC_MSG_CHECKING(for pointer-to-member parameter bug)
AC_TRY_COMPILE(
    [
struct pmf_foo {
	int bar() { return 0; };
};

template <class Class, class Result> 
class mem_fun_t {
protected:
    typedef Result (Class::*fun_type)(void);
    fun_type ptr;
public:
    mem_fun_t() {}
    mem_fun_t(fun_type p) : ptr(p) {}
    Result operator()(Class* x) const { return (x->*ptr)();}
};

template <class Class, class Result>
inline mem_fun_t <Class, Result> 
mem_fun(Result (Class::*ptr)(void)) {
    return mem_fun_t<Class, Result>(ptr);
}
],
    [pmf_foo pmf; (void)mem_fun(&pmf_foo::bar)(&pmf)],
    [ac_cv_pmf_bug="no"],
    [AC_DEFINE( __STL_MEMBER_POINTER_PARAM_BUG) ac_cv_pmf_bug="yes"])
AC_MSG_RESULT($ac_cv_pmf_bug)

AC_MSG_CHECKING(if bad_alloc defined in <new>)
AC_TRY_COMPILE(
    [#include <new.h>
     bad_alloc badalloc_foo() { bad_alloc err; return err;}],
    [(void)badalloc_foo()],
    [AC_DEFINE(__STL_BAD_ALLOC_DEFINED) ac_cv_bad_alloc="yes"],
    [ac_cv_bad_alloc="no"])
AC_MSG_RESULT($ac_cv_bad_alloc)

AC_MSG_CHECKING(for __type_traits automatic specialization)
AC_TRY_LINK(
    [template <class T> int tt_foo(const T&) {
	typedef __type_traits<T> traits;
	return 0;
     }],
    [(void)tt_foo(5)],
    [AC_DEFINE(__STL_AUTOMATIC_TYPE_TRAITS) ac_cv_type_traits="yes"],
    [ac_cv_type_traits="no"])
AC_MSG_RESULT($ac_cv_type_traits)



# package options - exceptions
AC_MSG_RESULT(***)
AC_MSG_RESULT($0: Setting implementation options...)
AC_MSG_RESULT(***)

AC_ARG_ENABLE(malloc,[--enable-malloc : set default alloc to malloc-based allocator ( malloc_alloc_template<instance_no>, alloc.h )
--disable-malloc : choose (default) sgi node allocator (__alloc<threads,no>  alloc.h )],
[
case "$enableval" in
	  yes ) AC_MSG_RESULT(Config arg  --enable-malloc : setting malloc_alloc as default alloc) 
                AC_DEFINE(__STL_USE_MALLOC);;
	    * ) AC_MSG_RESULT(Config default: using node __alloc as default alloc)
esac
],
[
 AC_MSG_RESULT(Config default: using node __alloc as default alloc)
]
)

AC_ARG_ENABLE(newalloc,[--enable-newalloc : set default alloc to new-based allocator ( new_alloc, alloc.h )
--disable-newalloc : choose (default) sgi allocator (__alloc<threads,no>  alloc.h )],
[
case "$enableval" in
	  yes ) AC_MSG_RESULT(Config arg  --enable-newalloc : setting new_alloc as default alloc) 
                AC_DEFINE(__STL_USE_NEWALLOC);;
	    * )
                AC_MSG_RESULT(Config default: using node __alloc as default alloc)
esac
],
[
 AC_MSG_RESULT(Config default: using node __alloc as default alloc)
]
)

AC_ARG_ENABLE(defalloc,[--enable-defalloc : make HP-style defalloc.h included in alloc.h )
--disable-defalloc : leave defalloc.h alone],
[
case "$enableval" in
	  no ) AC_MSG_RESULT(Config arg --disable-defalloc : not including HP-style defalloc.h into alloc.h);;

	  * ) AC_MSG_RESULT(Config default : including HP-style defalloc.h into alloc.h) 
                AC_DEFINE(__STL_USE_DEFALLOC)
esac
],
[
          AC_MSG_RESULT(Config default : not including HP-style defalloc.h into alloc.h)
]
)


AC_ARG_ENABLE(debugalloc,[--enable-debugalloc : use debug versions of allocators
--disable-debugalloc : not using debug allocators],
[
case "$enableval" in
	  yes ) AC_MSG_RESULT(Config arg --enable-debugalloc : use debug versions of allocators ) 
                AC_DEFINE(__STL_DEBUG_ALLOC);;
	  * )
          AC_MSG_RESULT(Config default : not using debug allocators)
esac
],
[
          AC_MSG_RESULT(Config default : not using debug allocators)
]
)

if test "$ac_cv_exceptions" = yes; then
AC_ARG_ENABLE(exceptions,[--enable-exceptions Use exceptions support (default if posssible)
 --disable-exceptions Don't use exceptions support],
[
case "$enableval" in
           no) AC_DEFINE(__STL_NO_EXCEPTIONS)
               AC_MSG_RESULT(Config arg --disable-exceptions : disabling exceptions by user request);;
           *)  AC_MSG_RESULT(Config default: exceptions enabled)
esac
],
[AC_MSG_RESULT(Config default: exceptions enabled) ]
)
else
 AC_MSG_RESULT(Compiler restriction : no exceptions support used)
fi

if test "$ac_cv_namespaces" = yes; then
AC_ARG_ENABLE(namespaces,[--enable-namespaces Use namespaces (default if posssible)
--disable-namespaces Don't use namespaces support],
[
case "$enableval" in
	no) AC_DEFINE(__STL_NO_NAMESPACES) 
            AC_MSG_RESULT(Config arg --disable-namespaces : code not put into std namespace by user request);;
	 *) AC_MSG_RESULT(Config default: code put into std namespace)
esac
],
[AC_MSG_RESULT(Config default: code put into std namespace)]
)

AC_ARG_ENABLE(std,[--enable-std Using namespace std  (default if posssible)
--disable-std Don't use namespace std by default],
[
case "$enableval" in
	no) AC_DEFINE(__STL_NO_USING_STD) 
            AC_MSG_RESULT(Config arg --disable-std : not using namespace std );;
	 *) AC_MSG_RESULT(Config default: using namespace std)
esac
],
[AC_MSG_RESULT(Config default: using namespace std)]
)
else
 AC_MSG_RESULT(Compiler restriction : std namespace not used)
fi


AC_ARG_ENABLE(abbrevs,[--enable-abbrevs : use abbreviated class names internally for linker benefit (don't affect interface)
--disable-abbrevs : don't use abbreviated names],
[
case "$enableval" in
	  yes ) AC_MSG_RESULT(Config arg --enable-abbrevs : using abbreviated class names internally) 
                AC_DEFINE(__STL_USE_ABBREVS);;
	  * )
          AC_MSG_RESULT(Config default : not using abbreviated class names internally)
esac
],
[
          AC_MSG_RESULT(Config default : not using abbreviated class names internally)
]
)


AC_DEFINE(__AUTO_CONFIGURED)

AC_MSG_RESULT(***)
AC_MSG_RESULT($0: setting up headers...)
AC_MSG_RESULT(***)
AC_OUTPUT(stlconf.h:config/stlconf.h)
AC_MSG_RESULT(***)
AC_MSG_RESULT($0: STL package tuned for use with \"${CXX}\" compiler.)
AC_MSG_RESULT($0: To restore original settings - copy ./config/stlconf.h to ./stlconf.h.)
AC_MSG_RESULT(***)

